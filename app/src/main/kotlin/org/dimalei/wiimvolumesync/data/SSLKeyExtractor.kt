package org.dimalei.wiimvolumesync.data

import android.util.Base64
import java.net.InetSocketAddress
import java.security.MessageDigest
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.SSLHandshakeException
import javax.net.ssl.SSLSocket


fun getServerPublicKeyPin(
    host: String,
    port: Int = 443,
    onSuccess: (String) -> Unit,
    onError: (Exception) -> Unit
) {
    var out: String
    try {
        val chain = captureServerCertChain(host, port)
        val leaf = chain[0]
        out = publicKeyPinBase64(leaf)
    } catch (e: Exception) {
        onError(e)
        return
    }
    onSuccess(out)
}

/*
* Trickery to get the SSL Pin
* generated by some AI
 */

fun captureServerCertChain(
    host: String,
    port: Int = 443
): Array<X509Certificate> {
    val tm = CertCapturingTrustManager()

    val ctx = SSLContext.getInstance("TLS")
    ctx.init(null, arrayOf(tm), null)

    val socket = ctx.socketFactory.createSocket() as SSLSocket
    socket.use {
        it.soTimeout = 5_000
        it.connect(InetSocketAddress(host, port), 5_000)

        try {
            it.startHandshake()
        } catch (e: SSLHandshakeException) {
            // Expected: handshake fails because TrustManager throws.
        }

        return tm.capturedChain
            ?: throw IllegalStateException("No certificate chain captured (server may not speak TLS on this port, timeout, etc.)")
    }
}


fun publicKeyPinBase64(cert: X509Certificate): String {
    val pubKeyDer = cert.publicKey.encoded
    val hash = MessageDigest.getInstance("SHA-256").digest(pubKeyDer)
    return Base64.encodeToString(hash, Base64.NO_WRAP)
}