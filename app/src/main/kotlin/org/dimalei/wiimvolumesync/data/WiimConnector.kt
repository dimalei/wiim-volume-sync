package org.dimalei.wiimvolumesync.data

import android.annotation.SuppressLint
import android.util.Base64
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.security.MessageDigest
import java.security.cert.CertificateException
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager


const val MAX_VOL = 99;
const val MIN_VOL = 0;

fun changePlayerVolume(
    ipAddress: String,
    expectedPinBase64: String,
    amount: Int,
    onSuccess: (String) -> Unit,
    onError: (Exception) -> Unit
) {
    getPlayerStatus(
        ipAddress = ipAddress,
        expectedPinBase64 = expectedPinBase64,
        onSuccess = {
            val currentVolume = it.getString("vol").toInt()
            val targetVolume = currentVolume + amount

            if (targetVolume !in MIN_VOL..MAX_VOL) {
                return@getPlayerStatus
            }
            setPlayerVolume(
                ipAddress = ipAddress,
                expectedPinBase64 = expectedPinBase64,
                volume = targetVolume,
                onSuccess = onSuccess,
                onError = { e -> throw e }
            )
        },
        onError = onError,
    )
}

fun getPlayerStatus(
    ipAddress: String,
    expectedPinBase64: String,
    onSuccess: (response: JSONObject) -> Unit,
    onError: (Exception) -> Unit
) {
    val url = HttpUrl.Builder()
        .scheme("https")
        .host(ipAddress)
        .addPathSegment("httpapi.asp")
        .addQueryParameter("command", "getPlayerStatus")
        .build()

    val client = buildPinnedClient(ipAddress, expectedPinBase64)

    val request = Request.Builder()
        .url(url)
        .get()
        .build()

    lateinit var responseJson: JSONObject

    try {
        val response = client.newCall(request).execute()
        val reader = BufferedReader(InputStreamReader(response.body.byteStream()))
        responseJson = JSONObject(reader.readText())
        onSuccess(responseJson)
    } catch (e: Exception) {
        onError(e)
        return
    }
}

fun getDeviceStatus(
    ipAddress: String,
    expectedPinBase64: String,
    onSuccess: (response: JSONObject) -> Unit,
    onError: (Exception) -> Unit
) {
    val url = HttpUrl.Builder()
        .scheme("https")
        .host(ipAddress)
        .addPathSegment("httpapi.asp")
        .addQueryParameter("command", "getStatusEx")
        .build()

    val client = buildPinnedClient(ipAddress, expectedPinBase64)

    val request = Request.Builder()
        .url(url)
        .get()
        .build()

    lateinit var responseJson: JSONObject

    try {
        val response = client.newCall(request).execute()
        val reader = BufferedReader(InputStreamReader(response.body.byteStream()))
        responseJson = JSONObject(reader.readText())
        onSuccess(responseJson)
    } catch (e: Exception) {
        onError(e)
        return
    }
}

fun setPlayerVolume(
    ipAddress: String,
    expectedPinBase64: String,
    volume: Int,
    onSuccess: (String) -> Unit,
    onError: (Exception) -> Unit
) {
    val url = HttpUrl.Builder()
        .scheme("https")
        .host(ipAddress)
        .addPathSegment("httpapi.asp")
        .addQueryParameter("command", "setPlayerCmd:vol:$volume")
        .build()

    val client = buildPinnedClient(ipAddress, expectedPinBase64)

    val request = Request.Builder()
        .url(url)
        .get()
        .build()

    val response: Response
    try {
        response = client.newCall(request).execute()
        onSuccess(response.toString())
    } catch (e: Exception) {
        onError(e)
        return
    }
}


// Generated by ChatGPT
private fun buildPinnedClient(
    ipAddress: String,
    expectedPinBase64: String
): OkHttpClient {
    val trustManager = @SuppressLint("CustomX509TrustManager")
    object : X509TrustManager {
        override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) = Unit

        override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
            if (chain.isEmpty()) throw CertificateException("Empty cert chain")

            // leaf cert public key -> SHA-256 -> base64
            val pubKeyDer = chain[0].publicKey.encoded
            val sha256 = MessageDigest.getInstance("SHA-256").digest(pubKeyDer)
            val actualB64 = Base64.encodeToString(sha256, Base64.NO_WRAP)

            if (actualB64 != expectedPinBase64) {
                throw CertificateException("Public key pin mismatch")
            }
        }

        override fun getAcceptedIssuers(): Array<X509Certificate> = emptyArray()
    }

    val sslContext = SSLContext.getInstance("TLS")
    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)

    return OkHttpClient.Builder()
        // Since you're connecting by IP and the cert won't match IP SAN, skip hostname verify ONLY for this IP.
        .hostnameVerifier { host, _ -> host == ipAddress }
        .sslSocketFactory(sslContext.socketFactory, trustManager)
        .build()
}