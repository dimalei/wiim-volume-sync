package org.dimalei.wiimvolumesync.data

import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.security.MessageDigest
import java.security.cert.CertificateException
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager

fun getPlayerStatus(
    ipAddress: String,
    expectedPinBase64: String,
    onSuccess: (response: JSONObject) -> Unit,
    onError: (Exception) -> Unit
) {

    val url = HttpUrl.Builder()
        .scheme("https")
        .host(ipAddress)
        .addPathSegment("httpapi.asp")
        .addQueryParameter("command", "getStatusEx")
        .build()

    val client = buildPinnedClient(ipAddress, expectedPinBase64)

    val request = Request.Builder()
        .url(url)
        .get()
        .build()


    lateinit var responseJson: JSONObject

    try {
        val response = client.newCall(request).execute()
        val reader = BufferedReader(InputStreamReader(response.body.byteStream()))
        responseJson = JSONObject(reader.readText())
    } catch (e: Exception) {
        onError(e)
        return
    }
    onSuccess(responseJson)
}

fun setPlayerVolume(
    ipAddress: String,
    expectedPinBase64: String,
    volume: Int,
    onSuccess: () -> Unit,
    onError: (Exception) -> Unit
) {
    val url = HttpUrl.Builder()
        .scheme("https")
        .host(ipAddress)
        .addPathSegment("httpapi.asp")
        .addQueryParameter("command", "setPlayerCmd:vol:$volume")
        .build()

    val client = buildPinnedClient(ipAddress, expectedPinBase64)

    val request = Request.Builder()
        .url(url)
        .get()
        .build()

    try {
        client.newCall(request).execute()
    } catch (e: Exception) {
        onError(e)
        return
    }
    onSuccess()
}


// Generated by ChatGPT
private fun buildPinnedClient(
    ipAddress: String,
    expectedPinBase64: String
): OkHttpClient {
    val trustManager = object : X509TrustManager {
        override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) = Unit

        override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
            if (chain.isEmpty()) throw CertificateException("Empty cert chain")

            // leaf cert public key -> SHA-256 -> base64
            val pubKeyDer = chain[0].publicKey.encoded
            val sha256 = MessageDigest.getInstance("SHA-256").digest(pubKeyDer)
            val actualB64 = android.util.Base64.encodeToString(sha256, android.util.Base64.NO_WRAP)

            if (actualB64 != expectedPinBase64) {
                throw CertificateException("Public key pin mismatch")
            }
        }

        override fun getAcceptedIssuers(): Array<X509Certificate> = emptyArray()
    }

    val sslContext = SSLContext.getInstance("TLS")
    sslContext.init(null, arrayOf<TrustManager>(trustManager), null)

    return OkHttpClient.Builder()
        // Since you're connecting by IP and the cert won't match IP SAN, skip hostname verify ONLY for this IP.
        .hostnameVerifier { host, _ -> host == ipAddress }
        .sslSocketFactory(sslContext.socketFactory, trustManager)
        .build()
}