package org.dimalei.wiimvolumesync.data

import android.annotation.SuppressLint
import android.content.Context
import android.util.Base64
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import org.json.JSONObject
import java.io.BufferedReader
import java.io.InputStreamReader
import java.security.MessageDigest
import java.security.cert.CertificateException
import java.security.cert.X509Certificate
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager

const val MAX_VOL = 99
const val MIN_VOL = 0

class WiimConnector(context: Context) {
    val TAG = javaClass.simpleName
    private val scope = CoroutineScope(Dispatchers.IO)

    private val configUpdater = ConfigUpdater(
        context = context,
        onIpUpdated = {
            ip = it
        },
        onPinBaseUpdated = {
            keyHash = it
            client = buildPinnedClient()
        },
        onVolumeStepUpdate = { volStep = it }
    )

    var currentVolume = -1
    lateinit var ip: String
    lateinit var keyHash: String
    var volStep = 2

    lateinit var client: OkHttpClient

    init {
        scope.launch {
            ip = configUpdater.getIp()
            keyHash = configUpdater.getPinBase()
            volStep = configUpdater.getVolStep()
            client = buildPinnedClient()
            Log.d(TAG, "Wiim Connector initialized $ip, $volStep, $keyHash")
        }
    }

    fun changePlayerVolume(
        direction: Volume,
    ) {
        if (currentVolume < 0) {
            getPlayerVolume()
            return
        }
        scope.launch {
            val targetVol = currentVolume + volStep * direction.factor
            if (targetVol in MIN_VOL..MAX_VOL) {
                setPlayerVolume(
                    volume = targetVol,
                    onSuccess = {
                        Log.i(TAG, "Volume set to $targetVol")
                        currentVolume = targetVol
                    },
                    onError = { Log.i(TAG, "Failed to set volume: $it") }
                )
            }
        }
    }

    private fun getPlayerVolume() {
        scope.launch {
            getPlayerStatus(
                {
                    currentVolume = it.getString("vol").toInt()
                    Log.d(TAG, "Current volume set $currentVolume")
                },
                { Log.e(TAG, "Fetching volume failed: $it") })
        }
    }

    fun getPlayerStatus(
        onSuccess: (response: JSONObject) -> Unit,
        onError: (Exception) -> Unit
    ) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(ip)
            .addPathSegment("httpapi.asp")
            .addQueryParameter("command", "getPlayerStatus")
            .build()

        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        lateinit var responseJson: JSONObject

        try {
            val response = client.newCall(request).execute()
            val reader = BufferedReader(InputStreamReader(response.body.byteStream()))
            responseJson = JSONObject(reader.readText())
            onSuccess(responseJson)
        } catch (e: Exception) {
            onError(e)
            return
        }
    }

    fun getDeviceStatus(
        onSuccess: (response: JSONObject) -> Unit,
        onError: (Exception) -> Unit
    ) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(ip)
            .addPathSegment("httpapi.asp")
            .addQueryParameter("command", "getStatusEx")
            .build()

        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        lateinit var responseJson: JSONObject

        try {
            val response = client.newCall(request).execute()
            val reader = BufferedReader(InputStreamReader(response.body.byteStream()))
            responseJson = JSONObject(reader.readText())
            onSuccess(responseJson)
        } catch (e: Exception) {
            onError(e)
            return
        }
    }

    fun setPlayerVolume(
        volume: Int,
        onSuccess: (String) -> Unit,
        onError: (Exception) -> Unit
    ) {
        val url = HttpUrl.Builder()
            .scheme("https")
            .host(ip)
            .addPathSegment("httpapi.asp")
            .addQueryParameter("command", "setPlayerCmd:vol:$volume")
            .build()

        val request = Request.Builder()
            .url(url)
            .get()
            .build()

        val response: Response
        try {
            response = client.newCall(request).execute()
            onSuccess(response.toString())
        } catch (e: Exception) {
            onError(e)
            return
        }
    }


    // Generated by ChatGPT
    private fun buildPinnedClient(
    ): OkHttpClient {
        val trustManager = @SuppressLint("CustomX509TrustManager")
        object : X509TrustManager {
            override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) = Unit

            override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
                if (chain.isEmpty()) throw CertificateException("Empty cert chain")

                // leaf cert public key -> SHA-256 -> base64
                val pubKeyDer = chain[0].publicKey.encoded
                val sha256 = MessageDigest.getInstance("SHA-256").digest(pubKeyDer)
                val actualB64 = Base64.encodeToString(sha256, Base64.NO_WRAP)

                if (actualB64 != keyHash) {
                    throw CertificateException("Public key pin mismatch")
                }
            }

            override fun getAcceptedIssuers(): Array<X509Certificate> = emptyArray()
        }

        val sslContext = SSLContext.getInstance("TLS")
        sslContext.init(null, arrayOf<TrustManager>(trustManager), null)

        return OkHttpClient.Builder()
            // Since you're connecting by IP and the cert won't match IP SAN, skip hostname verify ONLY for this IP.
            .hostnameVerifier { host, _ -> host == ip }
            .sslSocketFactory(sslContext.socketFactory, trustManager)
            .build()
    }

    enum class Volume(val factor: Int) {
        UP(1),
        DOWN(-1)
    }
}

